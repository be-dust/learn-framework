## 1. 双向绑定原理

当视图更新，数据就更新这个很简单，主要是针对一些表单提交，我们一般通过v-model来更新数据。

数据更新，视图就更新这个就比较复杂了。vue在初始化数据的时候会对数据进行数剧劫持进行响应化处理，在第一次渲染页面时会创建一个渲染watcher, 读取模板中的属性时会触发对应的getter，内部会把渲染watcher添加进自己的依赖里，当数据更新后会触发对应的setter，内部会通知渲染watcher去更新视图。这里面有几个关键点：
  
-  数据劫持 -> 响应化处理
-  创建watcher
-  依赖收集
-  派发更新即通知渲染watcher更新视图

## 2. 异步批量更新原理

其实就是nextTick的实现原理。
   
一句话总结就是把多次更新操作延迟到主线程所有的同步任务执行完之后。

比如我们写了下面这种代码
```js
setTimeout(() => {
	vm.msg = 'world';
	vm.lastName = '三';
	vm.firstName = '李';
}, 1000);

```
最终只会触发一次视图渲染，性能当然会提升。

先明确两点：
1. 渲染watcher，和watch中自定义的watcher会走到异步批量更新的逻辑中，计算属性watcher走的是另一套逻辑
2. 只有渲染watcher会更新视图

所以我们这里只说渲染watcher, ok, 那我们开始解析内部原理：

当我们修改属性值会通知渲染进行视图更新，这个时候并不会立即执行更新操作，而是会先把这些属性对应的渲染watcher都存在一个队列里，因为都是同一个渲染watcher，所以最后对列里只有一个渲染watcher(只考虑渲染watcher)，然后使用一个异步方法来执行对列中的渲染watcher的run方法也就是更新操作。关键就是这个异步方法，具体采用什么异步方法vue中有一个优先级的限制, Promise、MutationObserver、setImmediate、setTimeout, 前两个都是微任务，后两个都是宏任务，现代浏览器一般都支持Promise所以基本上都是采用的Promise，具体就是Promise的then方法，微任务会让更新操作更快执行。


## 数组依赖收集

对于数组，我们总结以下情况：

不能被检测的情况：
   1. 普通数组通过索引改变值不能被检测, 这种情形其实也可以实现但是当数组过大性能开销就会很大所以不建议这么做
   2. 数组长度变化不能被检测 

能被检测的情况
   1. 变异的数组方法可以被检测到
   2. 数组的项是对象的话会被检测
   3. 直接修改arr也会被检测到

假如我们传入的data是这个样子：
```js
data() {
	return {
		msg: 'hello',
		obj: {y: 1},
		arr: [1, 3, 4, {x: 1}],
	}
}
```
数据响应化处理
```js
export function defineReactive(data, key, value) {
	observe(value); 
	let dep = new Dep();
	Object.defineProperty(data, key, { 
		// 依赖收集
		get() {
			if (Dep.target) {
				dep.depend();
			}
			return value;
		},
		// 派发更新
		set(newValue) {
			if (newValue === value) return;
			observe(newValue);
			value = newValue;

			dep.notify();// 通知本属性所有的依赖进行更新
		}
	});
}
```
那么上面的这种写法我们已经对msg, obj, arr做了响应式处理,那么当执行下列操作
```js
vm.msg = 'xxx';
vm.obj = 'xxx';
vm.obj.y = 'xxx';
vm.arr = 'xxx';
vm.arr[3].x = 'xxx';
```
都会更新视图, 这是因为我们对
   1. data的每一个属性
   2. data下面的对象的每一个属性
   3. data下面的数组下面的对象的每一个属性都做了依赖收集

#### 数组本身如何进行依赖收集？
但是我们还差了一点那就是对数组本身进行依赖收集， 所以当我们使用数组的push、splice等方法时并不会触发视图更新, 需要进行特别的处理，那就是给数组上加一个___ob___属性。

#### 多维数组怎么依赖收集？

```js
data() {
	return {
		arr: [1, 3, 4, {x: 1}, [44]],
	}
}
```
首先我们明确一点：我们只能对属性进行数据劫持，从而这里最多只能对arr这个属性做数据劫持，我们在使用vm.arr取值触发arr的getter时可以对[1, 3, 4, {x: 1}, [44]]进行依赖收集，而内层数组当然是不能做数据劫持，因此需要在外层数组依赖收集之后做循环递归收集。


## 4.watch的原理

创建了一个新的watcher, 多了一个选项叫做user: true,表示他是一个用户在watch中自定义的watcher, 创建的时候先取watch属性的值作为老值保存起来，修改值之后触发watcher更新再取新值，比较二者，如果不相等的话就执行回调。

## 5.computed的原理

创建了一个新的watcher, 多了一个选项叫做lazy:true, 表示他是一个计算属性watcher。

vue也会使用Object.defineProperty方法把计算属性定义在了vm上, 这样就可以直接在模板中使用。

处理函数默认不执行，当取值的时候才会执行，而且会把这个值缓存起来，缓存主要是通过把dirty改为false来实现，当依赖的值变化会把dirty改为true, 这样就会重新取值。

刚开始取值的时候计算属性所依赖的属性会把该计算属性watcher和渲染watcher都收集起来，这样当依赖的属性变化之后就会重新计算计算属性的值，然后更新视图。

和watch相比：
   1. computed有缓存机制
   2. computed属性可以直接放在模板中使用, 因为他的处理函数返回的是一个值。watch只适合用来处理监控逻辑

## 6. 虚拟dom

```js
let app = document.getElementById('app');

for (let key in app) {
	console.log(key);
}

```
每一次渲染dom都会遍历这个dom的属性，dom属性很多，这样性能就不好。

虚拟dom，也叫虚拟节点，就是一个对象，这个对象描述了真实的dom。

#### key的作用
vue使用key来唯一标识虚拟节点，这样能够准确的找到其对应真实dom。当列表发生变化时之前的元素都无需更改：
1. 新增时，只需要在合适的位置插入新的元素，其他元素不用改变。如果没有key的话就需要修改之前所有元素，最后再添加一个新的元素。
2. 删除时，只需要删除其中的某个元素，其他元素不用改变
3. 顺序发生变化，移动之前的元素即可
这样的话就能提高渲染效率，提高页面性能。

还有就是循环的时候尽量不要用索引,因为索引不能唯一标识虚拟节点

如果用索引的话：

比如旧的节点列表是:a b c d 索引分别对应 0 1 2 3, 新的节点列表是: d c b a, 而索引依旧是0 1 2 3, 这样的话虽然新的节点列表中的每一个节点都可以在旧的节点列表中匹配到但是节点的内容发生了变化，因此就需要一一去修改真实dom的内容，需要修改4次，这些修改可能会包含大量的dom操作，比如**a有1个子节点，而d有100个子节点，这样就会新创建99个子节点，也就会有99次真实dom创建和渲染。**而如果使用唯一标识的话只需要移动三次元素的位置就可以了，显然性能会得到提高。


## 7. 怎么理解vue渐进式开发
渐进式开发那必然是有一个基本的东西，也是核心的东西，对于vue来说这个核心的东西就是双向绑定和组件开发，在此基础之上如果我们想开发单页面应用那我们就可以使用vue-router,当项目越来越大组件间的通信就是一个大问题，这个时候我们就可以用vuex来对数据进行集中管理，同时我们也可以使用vue-cli来更方便的构建，这一系列就把vue变成了一个渐进式框架。
## 8. 什么是库？什么是框架？
jquery就是一个典型的库，提供了很多方法，我们主动地调用这些方法来实现自己的功能。而对框架来说，我们需要把特定代码放在特定的位置上，框架会帮我们来调用这些方法实现自己的功能， 这是一个被动的过程。
## 9. mvc和mvvm的区别
传统的mvc是用在后端开发中的，m就是model，对应都是数据库中的数据，v就是view，对应的是前端的页面，c就是controller，对应的是后端的控制器，根据用户输入的url来获取数据返回给页面。

mvvm就是把view拆封成了 view 和 viewmodel, 去掉了控制器。

model指的是js中的数据，viewmodel是视图模型， view就是前端页面, 数据通过viewmodel自动渲染到页面上，页面发生变化也会通过viewmodel更新数据，这就是双向绑定。这种情况下我们就不用手动去操作dom，十分方便。

## 10. vue的模板为什么只能有一个根节点？
vue是根据虚拟dom树来渲染页面的，既然是树当然必须只有一个根节点。

vue初次渲染时是先把老的vnode拷贝了一份，然后根据这个新的vnode生成了一个新的dom ? 

## 11. v-if 和 v-for不能连用
不能连用这里是指不能用在同一个元素上，主要是因为优先级问题：v-for的优先级要大于v-if的优先级 

我们想要的效果是如果show为false的话就不显示dom, 对于下面这种写法，效果虽然能实现但是性能会很差，因为这段代码编译后类似这个样子
```
arr.map(fruit => {
	return show ? 渲染(fruit) : ''
})
```
数组有多少项就要循环多少次，每次都要根据show来判断是否渲染dom，解决办法是用template包一层
```html
<template v-if="show">
<div v-for="fruit in arr" :key="fruit">{{fruit}}</div>
</template>
```
如果show为false，下面的逻辑就不走了，没有一次循环。